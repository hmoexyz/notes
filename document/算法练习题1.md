# 算法练习题

## 细胞增殖

![](https://i-blog.csdnimg.cn/direct/1c0311c6de3448689995e5e0abaf8250.png)![](https://i-blog.csdnimg.cn/direct/a7e3e5e170a240ba83eefc678aef40f0.png)![](https://i-blog.csdnimg.cn/direct/15ede2bbc23a43e8ab95d921f1f1e9c6.png)

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();//n个观测值
        long m = scanner.nextLong();//m组<增值基数，稳定基数>
        Map<Long, Long> freqMap = new HashMap<>((int) n);//存储观测值以及他对应出现的频率
        long maxObservation = 0;//记录最大的观测值
        //1.将输入的观测值存储到哈希表中，并找出最大的观测值
        for (int i = 0; i < n; i++) {
            long observation = scanner.nextLong();
            freqMap.put(observation, freqMap.getOrDefault(observation, 0L) + 1);
            maxObservation = Math.max(maxObservation, observation);
        }
        //2.对于每个B和S求出符合的总观测记录总数，该假说模式下的增值峰值
        for (long i = 0; i < m; i++) {
            long b = scanner.nextLong();
            long s = scanner.nextLong();

            long count = 0;//记录总观测记录数
            long maxPeak = 0;//记录最大峰值

            //2.1如果b是0，那么预测值只能是S
            if (b == 0) {
                if (freqMap.containsKey(s)) {
                    long freq = freqMap.get(s);
                    count += freq;
                    maxPeak = Math.max(maxPeak, freq);
                }
            } else if (b == 1) {
                //2.2如果b是1，那么预测值只能是1+s
                if (freqMap.containsKey(s + 1)) {
                    long freq = freqMap.get(s + 1);
                    count += freq;
                    maxPeak = Math.max(maxPeak, freq);
                }
            } else {
                //2.3当b是大于1的，那么预测值会不断增大到超过最大观测值
                long bTemp = b;
                for (long c = b + s; c <= maxObservation; c = (b *= bTemp) + s) {
                    if (freqMap.containsKey(c)) {
                        Long freq = freqMap.get(c);
                        count += freq;
                        maxPeak = Math.max(maxPeak, freq);
                    }
                }
            }
            //3.输出结果
            System.out.println(count + " " + maxPeak);
        }
        scanner.close();
    }
}
```

## 小店的经营分析

![](https://i-blog.csdnimg.cn/direct/dd79d16d5bd2430d950a188c66e9a405.png)![](https://i-blog.csdnimg.cn/direct/6a5ac29ace8f42e485d73a878cd72bb2.png)

你想要解决的是统计咖啡店连续经营周期中总利润落在指定区间 \[L, R\] 内的数量问题，核心是利用前缀和结合二分查找来高效计算符合条件的连续子数组个数。

#### 解题思路

1. **前缀和转换**：设前缀和数组`S`，其中`S[0] = 0`，`S[k]`表示前`k`天的利润总和。那么从第[`i`](https://xplanc.org/primers/document/zh/03.HTML/EX.HTML%20%E5%85%83%E7%B4%A0/EX.i.md)天到第`j`天的利润和为[`S[j+1] - S[i]`](https://xplanc.org/primers/document/zh/03.HTML/EX.HTML%20%E5%85%83%E7%B4%A0/EX.i.md)。
2. **问题转化**：要求[`L ≤ S[j+1] - S[i] ≤ R`](https://xplanc.org/primers/document/zh/03.HTML/EX.HTML%20%E5%85%83%E7%B4%A0/EX.i.md)，等价于[`S[j+1]-R ≤ S[i] ≤ S[j+1]-L`](https://xplanc.org/primers/document/zh/03.HTML/EX.HTML%20%E5%85%83%E7%B4%A0/EX.i.md)。

```java
import java.util.Scanner;
import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        //1.初始化输入
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        int[] P = new int[N];
        for (int i = 0; i < N; i++) {
            P[i] = scanner.nextInt();
        }
        int L = scanner.nextInt(), R = scanner.nextInt();
        //2.前缀和求解
        int result = 0;
        int currentSum = 0;
        TreeMap<Integer, Integer> countMap = new TreeMap<>();
        countMap.put(0, 1);
        for (int i = 0; i < P.length; i++) {
            currentSum += P[i];
            result += countMap.subMap(currentSum - R, true, currentSum - L, true)
                    .values().stream().mapToInt(Integer::intValue).sum();
            countMap.put(currentSum, countMap.getOrDefault(currentSum, 0) + 1);
        }
        System.out.println(result);
        scanner.close();
    }
}
```

## 整理科研数据文件

![](https://i-blog.csdnimg.cn/direct/2b0ee3577064474c8c881c442712b23d.png)![](https://i-blog.csdnimg.cn/direct/11591ff4f1eb40f1b8d2f5a9842b0820.png)

#### 解题思路

1. **分段处理**：将每个文件名分割成 “连续非数字段” 和 “连续数字段” 的列表（比如`ts010tc12`→`["ts","010","tc","12"]`）；
2. **逐段比较**：按规则比较两个文件名的分段列表，直到找到差异：  
   * 非数字段：按区分大小写的字典序比较；  
   * 数字段：转成数值比较大小；  
   * 不同类型段：数字段排在前面；
3. **前缀优先**：若一个是另一个的前缀，短的排前面；
4. **稳定性保证**：若两个文件名完全等价，保持它们在输入中的原始顺序

```java
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Main {
    private static final Pattern PATTERN = Pattern.compile("\\d+|\\D+");

    private static class FileComaprator implements Comparator<String> {
        @Override
        public int compare(String file1, String file2) {
            //1.将两个文件名字按照数字和非数字组进行拆分，收集成链表
            List<String> segments1 = splitTosegments(file1);
            List<String> segments2 = splitTosegments(file2);
            //2.逐个比较
            int minSize = Math.min(segments1.size(), segments2.size());
            for (int i = 0; i < minSize; i++) {
                int cmp = 0;
                String seg1 = segments1.get(i);
                boolean seg1isDigit = isDigitSegment(seg1);
                String seg2 = segments2.get(i);
                boolean seg2isDigit = isDigitSegment(seg2);
                //2.1如果两个分割片段都是数字，那么谁小谁在前面
                if (seg1isDigit && seg2isDigit) {
                    cmp = Integer.compare(Integer.parseInt(seg1), Integer.parseInt(seg2));
                } else if (!seg1isDigit && !seg2isDigit) {
                    //2.2两个都是字符串直接字符串比较
                    cmp = seg1.compareTo(seg2);
                } else {
                    //2.3一个数字一个字符，非数字串大
                    cmp = seg1isDigit ? -1 : 1;
                }
                //3.如果比较出了结果，直接返回
                if (cmp != 0) {
                    return cmp;
                }
            }
            //3.逐个比较失败，说明前minSize个二者是一样的，那么选择长度最短的优先
            if (segments1.size() != segments2.size()) {
                return segments1.size() > segments2.size() ? 1 : -1;
            }
            //4.如果完全相同那么按照原顺序保持不变
            return 0;
        }
    }

    private static List<String> splitTosegments(String s) {
        List<String> segments = new ArrayList<>();
        Matcher matcher = PATTERN.matcher(s);
        while (matcher.find()) {
            segments.add(matcher.group());
        }
        return segments;
    }

    private static boolean isDigitSegment(String s) {
        return Character.isDigit(s.charAt(0));
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.nextLine();
        List<String> fileList = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            String file = scanner.nextLine().trim();
            fileList.add(file);
        }
        Collections.sort(fileList, new FileComaprator());
        for (String file : fileList) {
            System.out.println(file);
        }
        scanner.close();
    }
}
```

---

> 《[2025.12.17华为软开](https://www.xyzblog.publicvm.com/bac32d7c6500dbfe6d661e48dbf94312b5761611762e121c8cda3a5755f26ee6)》 是转载文章，[点击查看原文](https://blog.csdn.net/weixin_74175349/article/details/157070390)。